<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coding For Future</title>
  
  <link href="//atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-03-15T04:25:17.379Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Wenyan Du</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读书笔记：面向对象编程</title>
    <link href="http://yoursite.com/2017/03/15/oop/"/>
    <id>http://yoursite.com/2017/03/15/oop/</id>
    <published>2017-03-15T01:48:11.000Z</published>
    <updated>2017-03-15T04:25:17.379Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是好多年前，在公司里跟同事做分享时写的一点东西，先拿出来充充数。<br>文章中借鉴了很多书中的东西。比如犀牛书，红皮书等，这些书看似基础，实则博大精深，每看一次都有不同的感受。</p>
<p><strong>一、概念：</strong></p>
<blockquote>
<p>面向对象编程（Object Oriented Programming, OOP, 面向对象程序设计）是一种<strong>计算机编程架构</strong>，OOP的一条基本原则是<em>计算机程序是由单个能够起到子程序作用的单元或对象组合而成</em>，OOP达到了软件工程的三个目标：<strong>重用性、灵活性和扩展性</strong>。为了实现整体运算，每个对象都能够接收信息、处理数据和向其它对象发送信息。首先，面向对象符合人类看待事物的一般规律。其次，采用面向对象方法可以使系统各部分各司其职、各尽所能。为编程人员敞开了一扇大门，使其编程的代码更简洁、更易于维护，并且具有更强的可重用性。  </p>
</blockquote>
<p><strong>二、javascript中的面向对象：</strong><br>我们可以把对象想象成现实世界中的某一个具体的事物，比如一部手机，就是一个对象，它有长、宽、高、颜<br>色、重量，这叫对象的属性，手机有打电话、发短信等功能，这些功能叫对象的方法。js中的对象是由系列名值对组成的，在js中，一切都是对象，如：数组，函数,连字符串，数值，布尔值也有包装对象。  </p>
<p><strong>1.创建对象：</strong><br>要写面向对象的程序，得先创建一个对象，在js中创建对象有多种方法：对象字面量、<code>Object</code>构造函数还有Object的create方法,如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person=&#123;&#125;;<span class="comment">//字面量表示法,推荐</span></div><div class="line"><span class="comment">//或者</span></div><div class="line"><span class="keyword">var</span> person=<span class="keyword">new</span> <span class="built_in">Object</span>();<span class="comment">//构造函数法</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> person=<span class="built_in">Object</span>.create(<span class="literal">null</span>);</div></pre></td></tr></table></figure>
<p><strong>2.添加属性与方法：</strong>有了对象，就可以为对象添加属性与方法（<em>方法其实与一般函数无异，当一个函数属于一个对象时，就叫对象的方法</em>），如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person=&#123;</div><div class="line"> <span class="attr">name</span>:<span class="string">"William"</span>,<span class="comment">//添加一个name属性</span></div><div class="line"> sayName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//添加一个sayName的方法</span></div><div class="line">   alert(<span class="keyword">this</span>.name);</div><div class="line"> &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//还可以用以下两种方式添加属性与方法</span></div><div class="line">person.name=<span class="string">"William"</span>;</div><div class="line">person.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">person[<span class="string">"name"</span>]=<span class="string">"William"</span>;</div><div class="line">person[<span class="string">"sayName"</span>]=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>.Name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义好了对象的属性与方法之后，我们就可以读取对象的属性，调用对象的方法,如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myName=person.name;<span class="comment">//读取对象的属性</span></div><div class="line"></div><div class="line">person.sayName();<span class="comment">//调用对象的方法。输出William</span></div></pre></td></tr></table></figure>
<p> <strong>3.存在的问题：</strong><br>上面的概念里提到，面向对象编程要实现软件工程的三个目标：<strong>重用性、灵活性和扩展性</strong> ,那我们看上面的方式能不能实现这个目标。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果我有另一个对象person2，需要从person对象方继承sayName方法，可以这样做</span></div><div class="line"><span class="keyword">var</span> person2=person;<span class="comment">//对象的继承</span></div><div class="line"><span class="comment">//因为person2名字不一样，所以我需要改变person2的name属性</span></div><div class="line">person2.name=<span class="string">'Jack'</span>;</div><div class="line"><span class="comment">//又因为另一个对象还具有别的功能（方法）：唱歌，所以需要扩展person2的方法</span></div><div class="line">person2.sing=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  alert(<span class="string">'I am singing'</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//现在我们来调用person2的方法</span></div><div class="line">person2.sayName()<span class="comment">//输出Jack，没什么问题。</span></div><div class="line"></div><div class="line"><span class="comment">//再调一下person的方法</span></div><div class="line">person.sayName();<span class="comment">//输出Jack</span></div><div class="line">person.sing();<span class="comment">//输出I am singing</span></div></pre></td></tr></table></figure>
<p>sing本来是person2扩展的方法，但现在person也有了此方法。也就是说，我们改变子对象的属性和方法时，父对象也受到了影响。这是什么原因造成的呢？那是因为，在js中，只有基本类型在赋值给另外的变量时，才会将自身复制一份，而对象是引用类型，在赋值给其它变量时，并不会复制自身，而只是将对象在内存中的地址(引用)(此处不确定)给了变量。也就是说，person与person2其实指向的是内存中的同一个对象。这也就不难理解，为什么我们改变person2的属性与方法时，person也会跟着改变了。如果我们有多个类似的对象，由于不能继承，我们就需要定义多个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a=<span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> b=a;</div><div class="line">b=<span class="number">10</span>;</div><div class="line"></div><div class="line">alert(b===a);<span class="comment">//false</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a=&#123;<span class="attr">name</span>:<span class="string">'William'</span>&#125;</div><div class="line"><span class="keyword">var</span> b=a;</div><div class="line">b=&#123;<span class="attr">name</span>:<span class="string">'Jack'</span>&#125;</div><div class="line"></div><div class="line">alert(b===a);<span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>由此可见，这种方式不能实现代码的重用与扩展。我们需要其它构建对象的方法。</p>
<p> <strong>4.类的概念:</strong></p>
<blockquote>
<p>类是现实生活中一类具有共同特征的事物的抽象，是面向对象编程的基础。</p>
</blockquote>
<p>上面是类的定义，如动物、植物，就是两种类。我们还可以把类看作是图纸或者模具,通过图纸和模具，可以生产出多个完全一样的产品。在程序中，模具就是类，生产出来的产品，就是类的实例。  </p>
<p> <strong>5.javascript中的类:</strong><br>javascript里并没有类的概念，但是有构造函数，它和其它语言的类是非常相似的。<br>顾名思义，构造函数是用来构造一个对象的，它需要通过关键字new来调用。如果你按普通的方式调用它，那它其实与普通函数并没有什么区别。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义一个构造函数。构造函数要首写字母大写，以便与普通函数区分</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  <span class="comment">//给实例添加一个属性</span></div><div class="line">  <span class="keyword">this</span>.name=name;</div><div class="line">  <span class="comment">//给实例添加一个方法</span></div><div class="line">  <span class="keyword">this</span>.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      alert(<span class="string">'My name is'</span>+<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p1=<span class="keyword">new</span> Person(<span class="string">'William'</span>);<span class="comment">//通过关键字new调用一个函数，会返回一个此构造函数的实例</span></div><div class="line"><span class="keyword">var</span> p2=Person(<span class="string">'William'</span>);<span class="comment">//错误。如果忘记加关键字new，不会返回实例，p2值是undefined</span></div></pre></td></tr></table></figure>
<p>其实构造函数就是一个构建对象的工厂，我们可以这样理解：<strong>构造函数执行时，首先创建一个对象，再给对象添加属性和方法，最后返回这个对象</strong>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> obj=&#123;&#125;;</div><div class="line">  </div><div class="line">  obj.name=name;</div><div class="line">  </div><div class="line">  obj.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">'My name is'</span>+<span class="keyword">this</span>.name);</div><div class="line">  &#125;;</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>注意：对于普通函数，不要通过new关键字调用，不然可能得不到你想要的结果</strong> </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> a+b;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> num=<span class="keyword">new</span> sum(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//错误，返回的是sum的实例，而不是计算结果。</span></div></pre></td></tr></table></figure>
<p>实例化了对象，我们就可以调用它的方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p1.sayName();<span class="comment">//输出My name is William</span></div></pre></td></tr></table></figure>
<p>如果我们需要多个对象，只需多次调用构造函数来生成实例对象就可以了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//再实例化一个对象</span></div><div class="line"><span class="keyword">var</span> p2=<span class="keyword">new</span> Person(<span class="string">'Jack'</span>);</div><div class="line"><span class="comment">//输出：My name is Jack</span></div><div class="line">p2.sayName();</div></pre></td></tr></table></figure>
<p>我们来扩展p2，给它添加一个方法，并重写它的sayName方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//重写sayName方法</span></div><div class="line">p2.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  alert(<span class="string">'hello'</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//扩展添加一个新方法 </span></div><div class="line">p2.eat=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  alert(<span class="string">'eating'</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">p2.sayName();<span class="comment">//hello</span></div><div class="line">p2.eat();<span class="comment">//eating</span></div><div class="line"></div><div class="line"><span class="comment">//下面我们在p1上调用这两个方法</span></div><div class="line"><span class="comment">//输出William,还是原来的值</span></div><div class="line">p1.sayName();</div><div class="line"></div><div class="line"><span class="comment">//错误，p1并没有eat方法</span></div><div class="line"><span class="comment">//也就是说，我们重写p2的sayName方法，扩展一个eat方法，并没有影响另一个实例p1</span></div><div class="line"><span class="comment">//更进一步说，我们实例化一千个对象，这一千个对象都是不同的。但他们都是由一个构造函数构造的。</span></div><div class="line"><span class="comment">//这样就节省了很多代码。</span></div><div class="line">p1.eat();</div></pre></td></tr></table></figure>
<p>到现在为止，似乎面向对象的扩展性与灵活性都解决了。但写程序不只是解决问题，还对性能有要求。在现实世界中，一个人具有吃饭这个方法，另一个人具有另一个人的吃饭方法，这没有任何问题。但在程序中，存放对象及对象的属性与方法是需要内存空间的，一个对象的方法与属性越多，它占用的内存空间就越大。所以我们期望的是：<strong>两个对象具有不同的属性（就好比人有高矮胖瘦），但它们的方法应该共享（因为功能是一样的)</strong>，下面我们看p1与p2是不是共享一个方法的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//判断p1与p2的sayName方法是否相等</span></div><div class="line">alert(p1.sayName===p2.sayName);<span class="comment">//false。</span></div></pre></td></tr></table></figure>
<p>p1与p2的sayName方法并不相等，也就是说p1与p2各自拥有自己的、独立的sayName方法。当对象过多时，内存开销会非常大。所以要解决共享方法的问题，我们必须找其它方法。</p>
<p> <strong>6.对象的原型(prototype)：</strong></p>
<blockquote>
<p>每个javascript对象都有一个原型(prototype属性)，原型上的方法，<strong>可以被所有实例共享</strong>。</p>
</blockquote>
<p>利用这个特点，我们可以把需要共享的方法，定义在对象的原型上，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person=<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name=name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Person.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  alert(<span class="string">'My name is'</span> +<span class="keyword">this</span>.name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们来检测，原型上的方法是不是被所有实例共享的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1=<span class="keyword">new</span> Person(<span class="string">'William'</span>);</div><div class="line"><span class="keyword">var</span> p2=<span class="keyword">new</span> Person(<span class="string">'Jack'</span>);</div><div class="line">alert(p1.sayName===p2.sayName);<span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>p1与p2的sayName方法是相等的，可见，它们确实是共享的一个方法。也就是说，即使实例化一千个对象，它们都是共享的同一个sayName方法，大大的节约了内存的开销。这是怎么做到的？下面来看原型链。</p>
<p><strong>7.原型链：</strong>  </p>
<blockquote>
<p>原型本身也是对象，它也有自己的原型，而它自己的原型对象又可以有自己的原型，这样就组成了一条链，这个链就是原型链。</p>
</blockquote>
<p>每个实例对象都有一个__proto__属性，这个属性指向了该实例的构造函数的原型对象。我们知道对象是引用类型，也就是说__proto__属性只是存了一个指针，并不包含对象。当我们调用一个实例的方法时，程序首先会在实例本身上寻找这个方法，如果找不到，程序会通过__proto__属性找到prototype对象，在prototype上查找这个方法，如果找到了就调用，如果没找到，它又会通过原型对象的原型去查找，直到找到顶层，如果顶层对象上也没有，就会抛出错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p1.sayName()<span class="comment">//其实p1实例上并没有sayName这个方法</span></div><div class="line">p1.__proto__.sayName;<span class="comment">//这时它会去原型对象上找这个方法</span></div></pre></td></tr></table></figure>
<p><strong>8.扩展与继承：</strong><br>下面通过一个例子来看，如何实现对象的扩展与继承。<br>先定义一个基础类型:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//定义一个动物的基类</span></div><div class="line"><span class="keyword">var</span> Animal=<span class="function"><span class="keyword">function</span>(<span class="params">weight</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.weight=weight;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//添加一个eatFood方法</span></div><div class="line">Animal.prototype.eatFood=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  alert(<span class="string">'I\'m eating!'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从基类上继承方法，还可以继承构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义一个胎生动物的类，胎生动物也是动物，也具有eatFood的功能,所以我们可以从Animal上继eatFood方法，而不用重写</span></div><div class="line"><span class="keyword">var</span> Vivipara=<span class="function"><span class="keyword">function</span>(<span class="params">weight</span>)</span>&#123;</div><div class="line">  <span class="comment">//继承构造函数</span></div><div class="line">  Animal.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//继承Animal的方法，有多种方式,第一种是让它们共享一个原型对型，</span></div><div class="line"><span class="comment">//但这种方式有个问题，因为对象是引用类型，如果修改其中一个，会影响另一个</span></div><div class="line">Vivipara.prototype=Animal.prototype;</div><div class="line"></div><div class="line"><span class="comment">//第二种是将Animal的实例，作为Vivipara的原型</span></div><div class="line">Vivipara.prototype=<span class="keyword">new</span> Animal();</div><div class="line"></div><div class="line"><span class="comment">//还有可以直接用Object.assign，复制一个原型对象</span></div><div class="line">Vivipara.prototype=<span class="built_in">Object</span>.assign(&#123;&#125;,Animal.prototype);</div><div class="line"></div><div class="line"><span class="comment">//通过继承，现在Vivipara也有了eatFood方法</span></div><div class="line"></div><div class="line"><span class="comment">//因为胎生动物可以发声，所以需要扩展，为其添加一个sayName方法</span></div><div class="line">Vivipara.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">'叽哩呱啦'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后我们试试重写基类的方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义一个人类</span></div><div class="line"><span class="keyword">var</span> Human=<span class="function"><span class="keyword">function</span>(<span class="params">weight,name</span>)</span>&#123;</div><div class="line">  Vivipara.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</div><div class="line">  <span class="keyword">this</span>.name=name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//人类也是胎生动物，所以我们可以从vivipara上继承eatFood与sayName方法</span></div><div class="line">Human.prototype=<span class="keyword">new</span> Vivipara();</div><div class="line"></div><div class="line"><span class="comment">//但是人类可以说话，可以正确说出自己的名字，所以我们需要重写sayName方法</span></div><div class="line"><span class="comment">//需要注意的是，这里的重写，其实并没有真的重写父类的方法，而是在当前类的原型上添加了一个与父类的方法同名的方法</span></div><div class="line"><span class="comment">//当调用一个对象的方法时，它如果在自己的身上或自己的原型身上找到了这个方法，就不会再去往上去找这个方法了。</span></div><div class="line">Human.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  alert(<span class="string">'My name is'</span> +<span class="keyword">this</span>.name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们定义好了三个类，尽管后面两个类都继承自别的类，但它们之间是互不影响的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bird=<span class="keyword">new</span> Animal();</div><div class="line"><span class="comment">//输出：I'm eating</span></div><div class="line">bird.eatFood();</div><div class="line"></div><div class="line"><span class="keyword">var</span> dog=<span class="keyword">new</span> Vivipara();</div><div class="line"><span class="comment">//输出：叽哩呱啦;</span></div><div class="line">dog.sayName();</div><div class="line"></div><div class="line"><span class="keyword">var</span> p1=<span class="keyword">new</span> Human(<span class="string">'Lucy'</span>);</div><div class="line"><span class="comment">//I'm eating，与父类共享了eatFood方法</span></div><div class="line">p1.eatFood();</div><div class="line"><span class="comment">//输出My name is Lucy,而不是叽哩呱啦</span></div><div class="line">p1.sayName();</div></pre></td></tr></table></figure>
<p> <strong>三、需要注意的地方：</strong>  </p>
<p><strong>1.不要在实例化对象上设置或读取prototype。</strong>  </p>
<p>实例上并没有prototype这个属性，取而代之的是，实例上有一个__proto__私有属性，指向了原型对象，既然是私有属性，我们也最好不要去读取或者修改它，因为不是所有浏览器都实现(开放)了它。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> p1=<span class="keyword">new</span> Person;</div><div class="line"><span class="comment">//不要这样做</span></div><div class="line">p1.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"><span class="comment">//也不要这样做</span></div><div class="line">p1.__proto__.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div></pre></td></tr></table></figure>
<p><strong>2.构造函数内及原型方法内关键字<code>this</code>的指向：</strong>  </p>
<p>这也是常常造成困惑的地方，在大多数情况下，方法内的this指向的是拥有此方法的对象。但在原型方法与构造函数内情况有点不一样了，看看下面的例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person=<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="comment">//如果作为普通函数调用，这里的this一般指向window，在严格模式下会抛出错误。</span></div><div class="line">    <span class="comment">// 但作为构造函数调用时，此处的this指向的是构造函数的实例</span></div><div class="line">    <span class="keyword">this</span>.name=name;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">Person.prototype=&#123;</div><div class="line">  <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//原型方法内的this要看调用情况而定了，如果是实例调用，this同样是指向实例</span></div><div class="line"><span class="keyword">var</span> person=<span class="keyword">new</span> Person(<span class="string">'Lily'</span>);</div><div class="line">person.sayName();<span class="comment">//this指向person</span></div><div class="line"></div><div class="line"><span class="comment">//如通通过下面的方法调用，this是指向原型对象,因为sayName方法的拥有者是原型对象，这符合上面说的大多数情况。</span></div><div class="line">Person.prototype.sayName();</div></pre></td></tr></table></figure>
<p><strong>3.静态方法（属性)、实例方法(属性)、原型方法(属性)：</strong></p>
<p>直接在构造函数上添加的方法(属性)，叫静态方法(属性)。可以通过构造函数直接调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"></div><div class="line">Person.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>.name);<span class="comment">//静态方法内的this关键字指向的是构造函数。</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//直接调用</span></div><div class="line">Person.sayName();<span class="comment">//Person，this指向的是Person，所以输出的是构造函数的名字</span></div><div class="line"></div><div class="line"><span class="comment">//相反，实例不访问不到构造函数的静态方法的</span></div><div class="line"><span class="keyword">var</span> p1=<span class="keyword">new</span> Person;</div><div class="line">p1.sayName();<span class="comment">//错误</span></div></pre></td></tr></table></figure>
<p>在构造函数内，通过this添加的方法(属性),叫实例方法(属性)。必须要先实例化才能调用，构造函数是不能访问的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person=<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  <span class="comment">//实例属性</span></div><div class="line">  <span class="keyword">this</span>.name=name;</div><div class="line">  <span class="comment">//实例方法</span></div><div class="line">  <span class="keyword">this</span>.eat=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      alert(<span class="string">'I am eating'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person=<span class="keyword">new</span> Person(<span class="string">'name'</span>);</div><div class="line"></div><div class="line">person.eat();</div><div class="line"></div><div class="line"><span class="comment">//如果构造函数直接调用，会发生错误</span></div><div class="line">Person.eat();</div></pre></td></tr></table></figure>
<p>在构造函数的原型上添加的方法(属性) ,叫原型方法(属性)。原型方法可以实例化后调用，也可以能过原型调用（但比较少见)。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Person.prototype=&#123;</div><div class="line"></div><div class="line">  <span class="comment">//原型属性</span></div><div class="line">  sex:<span class="string">'female'</span>,</div><div class="line">  <span class="comment">//原型方法</span></div><div class="line">  saySex:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//输出female，注意，此时实例是没有sex这个属性的，它是通过原型链，找到原型上的sex属性并输出</span></div><div class="line">    alert(<span class="keyword">this</span>.sex);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person=<span class="keyword">new</span> Person();</div><div class="line"></div><div class="line"><span class="comment">//通过实例调用</span></div><div class="line">person.saySex();</div><div class="line"></div><div class="line"><span class="comment">//可以通过原型对象直接调用,比较少见,在方法上下文(this)没有依赖时，可以这样做</span></div><div class="line">Person.prototype.saySex();</div><div class="line"></div><div class="line"><span class="comment">//错误，构造函数不能调用原型对象上的方法</span></div><div class="line">Person.saySex();</div></pre></td></tr></table></figure>
<p><strong>4.对象的私有属性与私有方法:</strong></p>
<p>在其它面向对象的语言中，对象有私有属性与私有方法，外部程序是无法调用与读取的。只能通过对象的提供的接口访问或修改。而js并没有私有这个概念，任何对象任何属性在任何地点都可以被修改。所以是没有私有属性与私有方法的。<br><strong>我们可以约定一种标识私有方法与私有属性的规则，如在前面加下划线</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  <span class="comment">//私有属性</span></div><div class="line">  <span class="keyword">this</span>._name=name;</div><div class="line">&#125;</div><div class="line">Person.prototype=&#123;</div><div class="line">  <span class="comment">//私有方法</span></div><div class="line">  _sayName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">getName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">setName</span>:<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>._name=name;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>也可以通过闭包实现私有属性与方法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">//私有属性，在闭包外是无法访问的</span></div><div class="line">  <span class="comment">//只能通过对外提供的接口访问与修改</span></div><div class="line">  <span class="keyword">var</span> count=<span class="number">0</span>;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    count++;</div><div class="line">  &#125;</div><div class="line">  Person.prototype=&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//接口访问count</span></div><div class="line">    getCount:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> count;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//接口设置count</span></div><div class="line">    setCount:<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">      <span class="keyword">if</span>(!isNumber(num))&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'参数类型不正确'</span>);</div><div class="line">      &#125;</div><div class="line">      count=num;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//私有方法，闭包外无法访问</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> num===<span class="string">'number'</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> Person;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>虽然js的对象属性可以在任何时间修改，但我们最好不要直接修改，而是通过该对象提供的接口进行修改。私有方法也不要去调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1=<span class="keyword">new</span> Person(<span class="string">'xiaoli'</span>);</div><div class="line">p1._name=<span class="string">'taoge'</span>;<span class="comment">//不提倡</span></div><div class="line">p1.setName(<span class="string">'William'</span>);<span class="comment">//正确</span></div><div class="line">p1._sayName();<span class="comment">//不提倡</span></div></pre></td></tr></table></figure>
<p>最后，面向对象的概念与实现方式基本就这些了，最重要的是思维方式，要达到一切皆对象的境界，当然此对象不是女朋友，程序员哪来的女朋友。不过也可以用下面一段代码聊以自慰：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Girl</span>(<span class="params">name,weight,boyfriend</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name=name;</div><div class="line">  <span class="keyword">this</span>.weight=weight;</div><div class="line">  <span class="keyword">this</span>.boyfriend=boyfriend;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Girl.prototype.sayLove=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'I love you:'</span>+<span class="keyword">this</span>.boyfriend.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Girl.prototype.kiss=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'I want to kiss you:'</span>+<span class="keyword">this</span>.boyfriend.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Girl.prototype.xxoo=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">//那啥，为了和谐就不实现这方法了</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">Girl.prototype.marry=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'we are get married:'</span>+ <span class="keyword">this</span>.boyfriend.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> me=&#123;</div><div class="line">  <span class="attr">name</span>:<span class="string">'写上你自己的名字'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> myGF1=<span class="keyword">new</span> Girl(<span class="string">'小芳'</span>,<span class="number">95</span>,me);</div><div class="line"><span class="keyword">var</span> myGF2=<span class="keyword">new</span> Girl(<span class="string">'小丽'</span>,<span class="number">100</span>,me);</div><div class="line"><span class="comment">//3千行之后,你就拥有后宫佳丽三千了，美去吧</span></div><div class="line"><span class="keyword">var</span> myGF3000=<span class="keyword">new</span> Girl(<span class="string">'小美'</span>,<span class="number">105</span>,me);</div><div class="line"></div><div class="line">myGF1.sayLove();</div><div class="line">myGF1.kiss();</div><div class="line">myGF1.xxoo();</div><div class="line">myGF1.marry();</div><div class="line"></div><div class="line">myGF3000.xxoo();</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是好多年前，在公司里跟同事做分享时写的一点东西，先拿出来充充数。&lt;br&gt;文章中借鉴了很多书中的东西。比如犀牛书，红皮书等，这些书看似基础，实则博大精深，每看一次都有不同的感受。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、概念：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquot
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="面向对象 原型 原型链 闭包 继承 扩展 复用" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE-%E9%97%AD%E5%8C%85-%E7%BB%A7%E6%89%BF-%E6%89%A9%E5%B1%95-%E5%A4%8D%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>千里之行，始于足下</title>
    <link href="http://yoursite.com/2017/03/14/my-fisrt-blog/"/>
    <id>http://yoursite.com/2017/03/14/my-fisrt-blog/</id>
    <published>2017-03-14T07:10:07.000Z</published>
    <updated>2017-03-14T09:18:13.279Z</updated>
    
    <content type="html"><![CDATA[<p>  想写博客很久了，身边的很多小伙伴也都有个人博客，但一直提不起劲儿。<br>  老实说，自己并不是一个善于表达的人,心里有时明明想的很清楚，但要说出来时，却往往词不达意,言辞匮乏,想写点东西，也不知道如何开头。<br>  俗话说：万事开头难，但如果不克服，就永远开不了头。所以，就从今天开始，迈出第一步。<br>  以后就用它来记录生活中的点点滴滴。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  想写博客很久了，身边的很多小伙伴也都有个人博客，但一直提不起劲儿。&lt;br&gt;  老实说，自己并不是一个善于表达的人,心里有时明明想的很清楚，但要说出来时，却往往词不达意,言辞匮乏,想写点东西，也不知道如何开头。&lt;br&gt;  俗话说：万事开头难，但如果不克服，就永远开不了头。
    
    </summary>
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
</feed>
