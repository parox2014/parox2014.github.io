<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>面向对象编程： | parox2014</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一、概念：

面向对象编程（Object Oriented Programming, OOP, 面向对象程序设计）是一种计算机编程架构，OOP的一条基本原则是计算机程序是由单个能够起到子程序作用的单元或对象组合而成，OOP达到了软件工程的三个目标：重用性、灵活性和扩展性。为了实现整体运算，每个对象都能够接收信息、处理数据和向其它对象发送信息。首先，面向对象符合人类看待事物的一般规律。其次，采用面">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象编程：">
<meta property="og:url" content="http://yoursite.com/2017/03/14/面向对象编程/index.html">
<meta property="og:site_name" content="parox2014">
<meta property="og:description" content="一、概念：

面向对象编程（Object Oriented Programming, OOP, 面向对象程序设计）是一种计算机编程架构，OOP的一条基本原则是计算机程序是由单个能够起到子程序作用的单元或对象组合而成，OOP达到了软件工程的三个目标：重用性、灵活性和扩展性。为了实现整体运算，每个对象都能够接收信息、处理数据和向其它对象发送信息。首先，面向对象符合人类看待事物的一般规律。其次，采用面">
<meta property="og:updated_time" content="2017-03-14T05:47:59.093Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面向对象编程：">
<meta name="twitter:description" content="一、概念：

面向对象编程（Object Oriented Programming, OOP, 面向对象程序设计）是一种计算机编程架构，OOP的一条基本原则是计算机程序是由单个能够起到子程序作用的单元或对象组合而成，OOP达到了软件工程的三个目标：重用性、灵活性和扩展性。为了实现整体运算，每个对象都能够接收信息、处理数据和向其它对象发送信息。首先，面向对象符合人类看待事物的一般规律。其次，采用面">
  
    <link rel="alternate" href="/atom.xml" title="parox2014" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">parox2014</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">码出个未来</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-面向对象编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/14/面向对象编程/" class="article-date">
  <time datetime="2017-03-14T03:48:39.000Z" itemprop="datePublished">2017-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      面向对象编程：
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p><strong>一、概念：</strong></p>
<blockquote>
<p>面向对象编程（Object Oriented Programming, OOP, 面向对象程序设计）是一种<strong>计算机编程架构</strong>，OOP的一条基本原则是<em>计算机程序是由单个能够起到子程序作用的单元或对象组合而成</em>，OOP达到了软件工程的三个目标：<strong>重用性、灵活性和扩展性</strong>。为了实现整体运算，每个对象都能够接收信息、处理数据和向其它对象发送信息。首先，面向对象符合人类看待事物的一般规律。其次，采用面向对象方法可以使系统各部分各司其职、各尽所能。为编程人员敞开了一扇大门，使其编程的代码更简洁、更易于维护，并且具有更强的可重用性。–百度百科  </p>
</blockquote>
<p><strong>二、javascript中的面向对象：</strong><br>我们可以把对象想象成现实世界中的某一个具体的事物，比如一部手机，就是一个对象，它有长、宽、高、颜<br>色、重量，这叫对象的属性，手机有打电话、发短信等功能，这些功能叫对象的方法。js中的对象是由系列名值对组成的，在js中，一切都是对象，如：字符串，数值，数组，函数等，但这里主要是指自定义对象。<br><strong>1.创建对象：</strong><br>要写面向对象的程序，得先创建一个对象，在js中创建对象有两种方法：对象字面量和<code>Object</code>构造函数,如下：</p>
<pre><code>var person={};//字面量表示法,推荐
  //或者
var person=new Object();//构造函数法
</code></pre><p><strong>2.添加属性与方法：</strong>有了对象，就可以为对象添加属性与方法（<em>方法其实与一般函数无异，当一个函数属于一个对象时，就叫对象的方法</em>），如下：</p>
<pre><code>var person={
       name:&quot;William&quot;,//添加一个name属性
       sayName:function(){//添加一个sayName的方法
           alert(this.name);
       }
    };

//还可以用以下两种方式添加属性与方法

  person.name=&quot;William&quot;;
  person.sayName=function(){
      alert(this.name);
  }

person[&quot;name&quot;]=&quot;William&quot;;
person[&quot;sayName&quot;]=function(){
   alert(this.Name);
}
</code></pre><p>定义好了对象的属性与方法之后，我们就可以读取对象的属性，调用对象的方法,如下：</p>
<pre><code>var myName=person.name;//读取对象的属性
person.sayName();//调用对象的方法。输出William
</code></pre><p> <strong>3.存在的问题：</strong><br>上面的概念里提到，面向对象编程要实现软件工程的三个目标：<strong>重用性、灵活性和扩展性</strong> ,那我们看上面的方式能不能实现这个目标。  </p>
<pre><code>//如果我有另一个对象person2，需要从person对象方继承sayName方法，可以这样做
var person2=person;//对象的继承
//因为person2名字不一样，所以我需要改变person2的name属性
person2.name=&apos;Jack&apos;;
//又因为另一个对象还具有别的功能（方法）：唱歌，所以需要扩展person2的方法
person2.sing=function(){
    alert(&apos;I am singing&apos;);
}
//现在我们来调用person2的方法
person2.sayName()//输出Jack，没什么问题。

//再调一下person的方法
person.sayName();//输出Jack
person.sing();//输出I am singing
</code></pre><p>sing本来是person2扩展的方法，但现在person也有了此方法。也就是说，我们改变子对象的属性和方法时，父对象也受到了影响。这是什么原因造成的呢？那是因为，在js中，只有基本类型在赋值给另外的变量时，才会将自身复制一份，而对象，函数，数组等引用类型，在赋值给其它变量时，并不会复制自身，而只是将对象在内存中的地址给了变量。也就是说，person与person2其实指向的是内存中的同一个对象。这也就不难理解，为什么我们改变person2的属性与方法时，person也会跟着改变了。如果我们有多个类似的对象，由于不能继承，我们就需要定义多个对象。</p>
<pre><code>var a=5;
var b=a;
b=10;

alert(b===a);//false

var a={name:&apos;William&apos;}
var b=a;
b={name:&apos;Jack&apos;}

alert(b===a);//true
</code></pre><p>由此可见，这种方式不能实现代码的重用与扩展。我们需要其它构建对象的方法。</p>
<p> <strong>4.类的概念:</strong></p>
<blockquote>
<p>类是现实生活中一类具有共同特征的事物的抽象，是面向对象编程的基础。</p>
</blockquote>
<p>上面是类的定义，如动物、植物，就是两种类。我们还可以把类看作是图纸或者模具,通过图纸和模具，可以生产出多个完全一样的产品。在程序中，模具就是类，生产出来的产品，就是类的实例。  </p>
<p>在其它言语中，都有类的概念，我们来看看PHP中如何定义一个类，并通过类实例化一个对象：</p>
<pre><code>//在PHP中，可以通过class关键字定义一个类
class Person{
    var $name;//定义类的公有属性
    private $age;//定义类私有属性
    function sayName(){
        echo($this-&gt;$name)
    }
    function setAge($age){//提供设置私有属性的方法,对属性值验证通过后才能设置
        if($age&lt;0||$age&gt;110){
            echo(&apos;年龄不符合要求&apos;);
        }else{
            $this-&gt;$age=$age;
        }
    }
}
//实例化一个对象，也可以理解为，通过模具，生产出来一个产品。
var $p1=new Person();
$p1-&gt;$name=&quot;William&quot;;//设置name属性
$p1-&gt;sayName();//输出William
$p1-&gt;$age=20;//错误，无法设置私有属性
$p1-&gt;setAge(20);
</code></pre><p> <strong>5.javascript中的类:</strong><br>javascript里并没有类的概念，但是有构造函数，它和其它语言的类是非常相似的。<br> 顾名思义，构造函数是用来构造一个对象的，它需要通过关键字new来调用。如果你按普通的方式调用它，那它其实与普通函数并没有什么区别。</p>
<pre><code>function Person(name){//定义一个构造函数。构造函数我们一般以大写字母开始
    this.name=name;//给实例添加一个属性
    this.sayName=function(){//给实例添加一个方法
        alert(&apos;My name is&apos;+this.name);
    }
}
</code></pre><p>下面调用构造函数，记住一定要加关键字<code>new</code></p>
<pre><code>var p1=new Person(&apos;William&apos;);//通过关键字new调用一个函数，会返回一个此构造函数的实例
var p1=Person(&apos;William&apos;);//错误。如果忘记加关键字new，不会返回实例，p1值是undefined
</code></pre><p><strong>注意：对于普通函数，不要通过new关键字调用，不然可能得不到你想要的结果</strong> </p>
<pre><code>function sum(a,b){
     return a+b;
 }
var num=new sum(2,3);//错误，返回的是sum的实例，而不是计算结果。
</code></pre><p> 实例化了对象，我们就可以调用它的方法</p>
<pre><code>p1.sayName();//输出My name is William
</code></pre><p>如果我们需要多个对象，只需多次调用构造函数来实例化对象就可以了。</p>
<pre><code>var p2=new Person(&apos;Jack&apos;);//再实例化一个对象
p2.sayName();//My name is Jack
</code></pre><p>我们来扩展p2，给它添加一个方法，并重写它的sayName方法</p>
<pre><code>p2.sayName=function(){//重写sayName方法
    alert(&apos;hello&apos;);
}
p2.eat=function(){
    alert(&apos;eating&apos;);//扩展添加一个新方法
}
p2.sayName();//hello
p2.eat();//eating
//下面我们在p1上调用这两个方法
p1.sayName();//William,还是输出的原来的值
p1.eat();//错误，p1并没有eat方法
//也就是说，我们重写p2的sayName方法，扩展一个eat方法，并没有影响另一个实例p1
//更进一步说，我们实例化一千个对象，这一千个对象都是不同的。但他们都是由一个构造函数构造的。
//这样就节省了很多代码。
</code></pre><p>到现在为止，似乎面向对象的扩展性与灵活性都解决了。但写程序不只是解决问题，还对性能有要求。在现实世界中，一个人具有吃饭这个方法，另一个人具有另一个人的吃饭方法，这没有任何问题。但在程序中，存放对象及对象的属性与方法是需要内存空间的，一个对象的方法与属性越多，它占用的内存空间就越大。所以我们期望的是：<strong>两个对象具有不同的属性（就好比人有高矮胖瘦），但它们的方法应该共享（因为功能是一样的)</strong>，下面我们看p1与p2是不是共享一个方法的</p>
<pre><code>//判断p1与p2的sayName方法是否相等
alert(p1.sayName===p2.sayName);//false。
</code></pre><p>p1与p2的方法并不相等，也就是说p1与p2各自存了一个sayName方法。当对象过多时，内存占用无疑会增加。所以要解决共享方法的问题，我们必须找其它方法。</p>
<p> <strong>6.对象的原型(prototype)：</strong></p>
<blockquote>
<p>每个javascript对象都有一个原型(prototype属性)，原型上的方法，<strong>可以被所有实例共享</strong>。</p>
</blockquote>
<p>上面提到，原型上的方法可以被所有实例共享，利用这个特点，我们可以把需要共享的方法，定义在对象的原型上，如下：</p>
<pre><code>var Person=function(name){
     this.name=name;
};

Person.prototype.sayName=function(){
     alert(&apos;My name is&apos; +this.name);
}
</code></pre><p>下面我们来检测，原型上的方法是不是被所有实例共享的</p>
<pre><code>var p1=new Person(&apos;William&apos;);
var p2=new Person(&apos;Jack&apos;);
alert(p1.sayName===p2.sayName);//true
</code></pre><p>p1与p2的sayName方法是相等的，可见，它们确实是共享的一个方法。也就是说，即使实例化一千个对象，它们都是共享的同一个sayName方法，大大的节约了内存的开销。这是怎么做到的？下面来看原型链。</p>
<p><strong>7.原型链：</strong>  </p>
<blockquote>
<p>原型本身也是对象，它也有自己的原型，而它自己的原型对象又可以有自己的原型，这样就组成了一条链，这个链就是原型链。</p>
</blockquote>
<p>每个实例对象都有一个__proto__属性，这个属性指向了该实例的构造函数的原型对象。我们知道对象是引用类型，也就是说__proto__属性只是存了一个指针，并不包含对象。当我们调用一个实例的方法时，程序首先会在实例本身上寻找这个方法，如果找不到，程序会通过__proto__属性找到prototype对象，在prototype上查找这个方法，如果找到了就调用，如果没找到，它又会通过原型对象的原型去查找，直到找到顶点。</p>
<pre><code>p1.sayName()//其实p1实例上并没有sayName这个方法
Person.prototype.sayName;//这时它会去原型对象上找这个方法
</code></pre><p><strong>8.扩展与继承：</strong><br>下面通过一个例子来看，如何实现对象的扩展与继承。<br>先定义一个基础对象（基类):</p>
<pre><code>var Animal=function(weight){
    this.weight=weight;
}//定义一个动物的基类
Animal.prototype.eatFood=function(){//添加一个eatFood方法
    alert(&apos;I\&apos;m eating!&apos;);
}
</code></pre><p>从基类上继承方法，还可以继承构造函数</p>
<pre><code>var Vivipara=function(weight){
        Animal.call(this,weight);//继承构造函数
    };//定义一个胎生动物的类，胎生动物也是动物，所以我们可以从Animal上继eatFood方法，而不用重写
Vivipara.prototype=new Animal();//继承Animal,现在Vivipara也有了eatFood方法
Vivipara.prototype.sayName=function(){//因为胎生动物可以发声，所以需要扩展，为其添加一个sayName方法
    alert(&apos;叽哩呱啦&apos;);
}
</code></pre><p>最后我们试试重写基类的方法</p>
<pre><code>var Human=function(name){
    this.name=name;
}//定义一个人类
Human.prototype=new Vivipara();//人类也是胎生动物，所以我们可以从vivipara上继承eatFood与sayName方法
//但是人类可以说话，可以正确说出自己的名字，所以我们需要重写sayName方法
//需要注意的是，这里的重写，其实并没有真的重写父类的方法，而是在当前类的原型上添加了一个与父类的方法同名的方法
//当调用一个对象的方法时，它如果在自己的身上或自己的原型身上找到了这个方法，就不会再去父类上找这个方法了。
Human.prototype.sayName=function(){
    alert(&apos;My name is&apos; +this.name);
}
</code></pre><p>现在我们定义好了三个类，尽管后面两个类都继承自别的类，但它们之间是互不影响的。</p>
<pre><code>var bird=new Animal();
bird.eatFood();//I&apos;m eating

var dog=new Vivipara();
dog.sayName();//叽哩呱啦;

var p1=new Human(&apos;Lucy&apos;);
p1.eatFood();//I&apos;m eating，与父类共享了eatFood方法
p1.sayName();//输出My name is Lucy,而不是叽哩呱啦
</code></pre><p> <strong>三、需要注意的地方：</strong>  </p>
<p>#####1.不要在实例化对象上设置或读取prototype。<br>实例上并没有prototype这个属性，取而代之的是，实例上有一个__proto__私有属性，指向了原型对象，既然是私有属性，我们也最好不要去读取或者修改它，因为不是所有浏览器都实现(开放)了它。</p>
<pre><code>var Person=function(){}
var p1=new Person;
p1.prototype.sayName=function(){};//不要这样做
p1.__proto__.sayName=function(){};//不要这样做
</code></pre><p>#####2.构造函数内及原型方法内关键字<code>this</code>的指向：<br>这也是常常造成困惑的地方，在大多数情况下，方法内的this指向的是拥有此方法的对象。但在原型方法与构造函数内情况有点不一样了，看看下面的例子:</p>
<pre><code>var Person=function(name){
    this.name=name;//如果作为普通函数调用，这里的this一般指向window，但作为构造函数调用时，此处的this指向的是构造函数的实例
}

Person.prototype={
    sayName:function(){
        console.log(this.name);
    }
}

//原型方法内的this要看调用情况而定了，如果是实例调用，this同样是指向实例
var person=new Person(&apos;Lily&apos;);
person.sayName();//this指向person

//如通通过下面的方法调用，this是指向原型对象,因为sayName方法的拥有者是原型对象，这符合上面说的大多数情况。
Person.prototype.sayName();
</code></pre><p>#####3.静态方法（属性)、实例方法(属性)、原型方法(属性)：(也许名称并不标准，理解它的意思就行了)  </p>
<p>直接在构造函数上添加的方法(属性)，叫静态方法(属性)。可以通过构造函数直接调用。</p>
<pre><code>var Person=function(){};
Person.sayName=function(){
    alert(this.name);//静态方法内的this关键字指向的是构造函数。
}
//直接调用
Person.sayName();//Person，this指向的是Person，所以输出的是构造函数的名字
//相反，实例不访问不到构造函数的静态方法的
var p1=new Person;
p1.sayName();//错误
</code></pre><p>在构造函数内，通过this添加的方法(属性),叫实例方法(属性)。必须要先实例化才能调用，构造函数是不能访问的。</p>
<pre><code>var Person=function(name){
    this.name=name;//实例属性
    this.eat=function(){//实例方法
        alert(&apos;I am eating&apos;);
    }
}

var person=new Person(&apos;name&apos;);
person.eat();
//如果构造函数直接调用，会发生错误
Person.eat();
</code></pre><p>在构造函数的原型上添加的方法(属性) ,叫原型方法(属性)。原型方法可以实例化后调用，也可以能过原型调用（但比较少见)。  </p>
<pre><code>Person.prototype={
    sex:&apos;female&apos;,//原型属性
    saySex:function(){//原型方法
        alert(this.sex);//female，注意，此时实例是没有sex这个属性的，它是通过原型链，找到原型上的sex属性并输出
    }
}
var person=new Person();
person.saySex();//通过实例调用
Person.prototype.saySex();//可以通过原型对象直接调用,比较少见,在方法对实例属性或方法没有依赖时，可以这样做

Person.saySex();//错误，构造函数不能调用原型对象上的方法
</code></pre><p>#####4.对象的私有属性与私有方法<br>在其它面向对象的语言中，对象有私有属性与私有方法，外部程序是无法调用与读取的。只能通过对象的提供的接口进行通信。而js是一门动态语言，任何对象任何属性在任何地点都可以被修改。所以是没有私有属性与私有方法的。<br>我们可以约定一种标识私有方法与私有属性的方法，如在前面加下划线</p>
<pre><code>function Person(name){
    this._name=name;//私有变量
}
Person.prototype={
    _sayName:function(){//私有方法
        alert(this.name);
    },
    getName:function(){
        return this._name;
    },
    setName:function(name){
        this._name=name;
    }
}
</code></pre><p>虽然js的对象属性可以在任务时间修改，但我们最好不要直接修改，而是通过该对象提供的接口进行修改。私有方法也不要去调用。</p>
<pre><code>var p1=new Person(&apos;xiaoli&apos;);
p1._name=&apos;taoge&apos;;//不提倡
p1.setName(&apos;William&apos;);//正确
p1._sayName();//不提倡
</code></pre><p><strong>四、实例：用面向对向的方式写一个音乐播放器</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/14/面向对象编程/" data-id="cj095odmf0002j0wc0rym2npi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/03/14/post/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          my first blog
        
      </div>
    </a>
  
  
    <a href="/2017/03/14/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/js/" style="font-size: 10px;">js</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/14/post/">my first blog</a>
          </li>
        
          <li>
            <a href="/2017/03/14/面向对象编程/">面向对象编程：</a>
          </li>
        
          <li>
            <a href="/2017/03/14/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 慕苏<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>